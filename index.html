<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DMM Step Planner (GitHub Pages Auto Pack)</title>
  <style>
    :root{
      --panel:#161a22;
      --panel2:#1c2230;
      --text:#e8ecf4;
      --muted:#a9b3c7;
      --border:#2a3244;
      --danger:#ff5d6c;
      --ok:#53d18a;
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:linear-gradient(180deg,#0b0d11, #0f1115 50%, #0c0e12);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:10;
      background:rgba(22,26,34,.9);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--border);
      padding:12px 16px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    h1{margin:0; font-size:15px; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:12px}
    .grow{flex:1 1 auto; min-width:240px}

    .btn{
      background:var(--panel2);
      color:var(--text);
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px 10px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{border-color:#3a4763}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:rgba(122,162,255,.14); border-color:rgba(122,162,255,.35)}
    .btn.ok{background:rgba(83,209,138,.12); border-color:rgba(83,209,138,.35)}
    .btn.danger{background:rgba(255,93,108,.10); border-color:rgba(255,93,108,.35); color:#ffd8dc}
    .pill{
      font-family:var(--mono);
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      background:rgba(255,255,255,.03);
      white-space:nowrap;
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:14px;
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:14px;
    }
    @media (max-width: 980px){ main{grid-template-columns: 1fr} }

    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
    }
    .card .hd{
      padding:12px;
      border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.02);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .bd{padding:12px}
    .muted{color:var(--muted)}

    input[type="text"], textarea{
      width:100%;
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      outline:none;
      font-family:var(--sans);
    }
    input[type="text"]:focus, textarea:focus{border-color:rgba(122,162,255,.55)}
    textarea{min-height:140px; resize:vertical; line-height:1.35}

    .help{
      font-size:12px; line-height:1.35; color:var(--muted);
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,.02);
    }
    .help code{
      font-family:var(--mono);
      font-size:11px;
      background:rgba(255,255,255,.04);
      padding:1px 6px;
      border:1px solid var(--border);
      border-radius:8px;
      color:var(--text);
    }

    details.section{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,.02);
      overflow:hidden;
      margin-bottom:10px;
    }
    details.section.dragOver{ outline:2px solid rgba(122,162,255,.55); outline-offset:2px; }
    details.section[open]{background:rgba(122,162,255,.05); border-color:rgba(122,162,255,.25)}
    summary.sectionSum{
      list-style:none;
      cursor:pointer;
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
    }
    summary.sectionSum::-webkit-details-marker{display:none}
    summary.sectionSum.selected{
      background:rgba(122,162,255,.10);
      border-bottom:1px solid rgba(122,162,255,.18);
    }
    .secLeft{display:flex; align-items:center; gap:8px; min-width:0;}
    .caret{
      width:20px; height:20px;
      border:1px solid var(--border);
      border-radius:8px;
      display:flex; align-items:center; justify-content:center;
      color:var(--muted);
      font-family:var(--mono);
      flex:0 0 auto;
    }
    details.section[open] .caret{color:var(--text); border-color:rgba(122,162,255,.45)}
    .secTitle{
      font-weight:800; font-size:13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .secMeta{
      color:var(--muted);
      font-size:12px;
      font-family:var(--mono);
      flex:0 0 auto;
    }

    .dragHandle{
      width:22px; height:22px;
      border-radius:8px;
      border:1px solid var(--border);
      display:flex; align-items:center; justify-content:center;
      color:var(--muted);
      background:rgba(0,0,0,.18);
      cursor:grab;
      font-family:var(--mono);
      flex:0 0 auto;
    }
    .dragHandle:active{ cursor:grabbing; }
    .dragHandle:hover{ border-color:#3a4763; color:var(--text); }

    .secBody{padding:10px 12px; border-top:1px solid var(--border)}
    .rowBtns{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .tiny{font-size:12px; padding:6px 8px; border-radius:10px;}

    .step{
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px;
      background:rgba(0,0,0,.18);
      margin-top:10px;
    }
    .stepTop{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom:10px;
    }
    .stepTop .num{
      width:26px; height:26px;
      border-radius:9px;
      border:1px solid var(--border);
      display:flex; align-items:center; justify-content:center;
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
      background:rgba(0,0,0,.2);
      flex:0 0 auto;
    }
    .stepTop input{flex:1 1 auto; padding:8px 10px; border-radius:12px;}
    .stepGrid{display:grid; grid-template-columns: 260px 1fr; gap:10px;}
    @media (max-width: 980px){ .stepGrid{grid-template-columns: 1fr} }

    .imgBox{
      border:2px dashed rgba(122,162,255,.35);
      border-radius:14px;
      min-height:170px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:10px;
      background:rgba(122,162,255,.06);
      cursor:pointer;
      position:relative;
      overflow:hidden;
      outline:none;
    }
    .imgBox.dragover{border-color:rgba(122,162,255,.8); background:rgba(122,162,255,.12); color:var(--text);}
    .imgBox:focus{border-color:rgba(122,162,255,.8); box-shadow:0 0 0 3px rgba(122,162,255,.15);}
    .imgBox .hint{color:var(--muted); font-size:12px; line-height:1.35;}
    .imgBox img{
      width:100%;
      height:100%;
      object-fit:cover;
      border-radius:12px;
      border:1px solid var(--border);
      display:none;
    }
    .imgActions{display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;}
    .hide{display:none !important}

    .lightbox{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.75);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:20px;
    }
    .lightboxInner{
      max-width:min(1200px, 96vw);
      max-height:92vh;
      width:100%;
      background:rgba(22,26,34,.98);
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .lightboxTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.02);
    }
    .lightboxTitle{
      font-size:12px;
      color:var(--muted);
      font-family:var(--mono);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .lightboxClose{
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
    }
    .lightboxClose:hover{ border-color:#3a4763; }
    .lightboxBody{
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.25);
    }
    .lightboxBody img{
      max-width:100%;
      max-height:80vh;
      border-radius:12px;
      border:1px solid var(--border);
    }
  </style>
</head>
<body>

<header>
  <div class="grow">
    <h1>DMM Step Planner</h1>
    <div class="sub">
      Auto-loads pack from <code class="pill">/data/dmm_plan.zip</code> ‚Ä¢ Bump version to force updates
    </div>
  </div>

  <button class="btn primary" id="addSectionBtn">‚ûï Add section</button>
  <button class="btn primary" id="addStepBtn">‚ûï Add step</button>

  <button class="btn ok" id="exportBtn">‚¨áÔ∏è Export JSON</button>
  <label class="btn" for="importFile">‚¨ÜÔ∏è Import JSON</label>
  <input id="importFile" class="hide" type="file" accept="application/json" />

  <button class="btn ok" id="exportPackBtn">üì¶ Export Pack (.zip)</button>
  <label class="btn" for="importPackFile">üì¶ Import Pack (.zip)</label>
  <input id="importPackFile" class="hide" type="file" accept=".zip,application/zip" />

  <button class="btn ok" id="exportStandaloneBtn">üß© Export Standalone HTML</button>

  <button class="btn danger" id="resetBtn">‚Ü©Ô∏è Reset</button>

  <span class="pill" id="savePill">Saved</span>
  <span class="pill" id="storagePill">Storage: ‚Ä¶</span>
</header>

<main>
  <section class="card">
    <div class="hd"><div style="font-weight:800; font-size:13px">Plan info</div></div>
    <div class="bd">
      <label class="muted" for="planTitle">Plan Title</label>
      <input id="planTitle" type="text" placeholder="e.g., DMM Jan 30 ‚Äî Callisto Cave (61‚Äì80) Plan" />

      <div style="height:10px"></div>

      <div class="help">
        <b>GitHub Pages Auto Pack</b><br/>
        This page auto-imports <code>./data/dmm_plan.zip</code> once per browser per version.<br/>
        When you upload a new zip, bump <code>AUTO_PACK_VERSION</code> in the script.
      </div>

      <div style="height:10px"></div>
      <div class="help">
        <b>Selected section:</b> <span id="selectedLabel" class="muted">(none)</span>
      </div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div style="font-weight:800; font-size:13px">Sections & Steps</div>
      <div class="muted" style="font-size:12px" id="countLabel"></div>
    </div>
    <div class="bd" id="sectionsRoot"></div>
  </section>
</main>

<div id="lightbox" class="lightbox hide" aria-hidden="true">
  <div class="lightboxInner" role="dialog" aria-modal="true">
    <div class="lightboxTop">
      <div id="lightboxTitle" class="lightboxTitle"></div>
      <button id="lightboxClose" class="lightboxClose">Close (Esc)</button>
    </div>
    <div class="lightboxBody">
      <img id="lightboxImg" alt="Large preview" />
    </div>
  </div>
</div>

<!-- Embedded payload gets injected for Standalone exports -->
<script id="__DMM_EMBEDDED__" type="application/json"></script>

<!-- JSZip for pack import/export -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
  // ===== Auto-load pack config (GitHub Pages) =====
  // Put your zip here in the repo: /data/dmm_plan.zip
  const AUTO_PACK_URL = "./data/dmm_plan.zip";
  // BUMP THIS STRING every time you upload a new zip, so viewers re-import it.
  const AUTO_PACK_VERSION = "2026-01-05";


  // ===== Config =====
  const PLAN_STORAGE_KEY = "dmm_plan_text_v3";
  const IMG_DB_NAME = "dmm_plan_images_v3";
  const IMG_STORE = "images";
  const EMBED_SCRIPT_ID = "__DMM_EMBEDDED__";

  const $ = (id) => document.getElementById(id);

  const sectionsRoot = $("sectionsRoot");
  const planTitleEl = $("planTitle");
  const savePill = $("savePill");
  const storagePill = $("storagePill");
  const selectedLabel = $("selectedLabel");
  const countLabel = $("countLabel");

  const addSectionBtn = $("addSectionBtn");
  const addStepBtn = $("addStepBtn");

  const exportBtn = $("exportBtn");
  const importFile = $("importFile");

  const exportPackBtn = $("exportPackBtn");
  const importPackFile = $("importPackFile");

  const exportStandaloneBtn = $("exportStandaloneBtn");
  const resetBtn = $("resetBtn");

  // ===== Lightbox =====
  const lightbox = $("lightbox");
  const lightboxImg = $("lightboxImg");
  const lightboxTitle = $("lightboxTitle");
  const lightboxClose = $("lightboxClose");
  let lightboxObjUrl = null;

  function openLightboxFromBlob(blob, titleText="Image") {
    if (!blob) return;
    if (lightboxObjUrl) URL.revokeObjectURL(lightboxObjUrl);
    lightboxObjUrl = URL.createObjectURL(blob);
    lightboxImg.src = lightboxObjUrl;
    lightboxTitle.textContent = titleText || "Image";
    lightbox.classList.remove("hide");
    lightbox.setAttribute("aria-hidden", "false");
  }
  function closeLightbox() {
    lightbox.classList.add("hide");
    lightbox.setAttribute("aria-hidden", "true");
    lightboxImg.removeAttribute("src");
    if (lightboxObjUrl) URL.revokeObjectURL(lightboxObjUrl);
    lightboxObjUrl = null;
  }
  lightboxClose.addEventListener("click", closeLightbox);
  lightbox.addEventListener("click", (ev) => { if (ev.target === lightbox) closeLightbox(); });
  document.addEventListener("keydown", (ev) => {
    if (ev.key === "Escape" && !lightbox.classList.contains("hide")) closeLightbox();
  });

  const uid = () => "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);

  // Ask browser to persist storage if possible
  (async () => {
    if (navigator.storage?.persist) {
      try { await navigator.storage.persist(); } catch {}
    }
  })();

  // ===== IndexedDB =====
  function openImgDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(IMG_DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(IMG_STORE)) db.createObjectStore(IMG_STORE);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbPutImage(key, blob) {
    const db = await openImgDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IMG_STORE, "readwrite");
      tx.objectStore(IMG_STORE).put(blob, key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  async function idbGetImage(key) {
    const db = await openImgDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IMG_STORE, "readonly");
      const req = tx.objectStore(IMG_STORE).get(key);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbDeleteImage(key) {
    const db = await openImgDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IMG_STORE, "readwrite");
      tx.objectStore(IMG_STORE).delete(key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  async function idbClearAllImages() {
    const db = await openImgDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IMG_STORE, "readwrite");
      tx.objectStore(IMG_STORE).clear();
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  // ===== State =====
  const DEFAULT_STATE = () => ({
    title: "DMM Plan",
    selectedSectionId: null,
    sections: [
      {
        id: uid(),
        title: "New Section",
        open: true,
        steps: [
          { id: uid(), title: "New step", text: "", imageId: "" }
        ]
      }
    ]
  });

  function loadPlan() {
    try {
      const raw = localStorage.getItem(PLAN_STORAGE_KEY);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }

  let state = loadPlan() || DEFAULT_STATE();
  if (!state.selectedSectionId && state.sections[0]) state.selectedSectionId = state.sections[0].id;

  function allSteps() {
    return (state.sections || []).flatMap(s => s.steps || []);
  }
  function selectedSection() {
    return state.sections.find(s => s.id === state.selectedSectionId) || null;
  }
  function setSelectedSection(sectionId) {
    state.selectedSectionId = sectionId;
    const sel = selectedSection();
    selectedLabel.textContent = sel ? sel.title : "(none)";
    document.querySelectorAll("summary.sectionSum").forEach(sum => {
      sum.classList.toggle("selected", sum.dataset.sid === sectionId);
    });
    saveSoon();
  }

  // ===== Save debounce =====
  let saveTimer = null;
  function setSaveStatus(text, ok=true) {
    savePill.textContent = text;
    savePill.style.borderColor = ok ? "rgba(83,209,138,.55)" : "rgba(255,93,108,.55)";
  }
  function saveNow() {
    try {
      localStorage.setItem(PLAN_STORAGE_KEY, JSON.stringify(state));
      setSaveStatus("Saved", true);
    } catch (e) {
      console.error(e);
      setSaveStatus("Save failed", false);
      alert("Plan save failed.");
    }
  }
  function saveSoon() {
    setSaveStatus("Saving‚Ä¶", true);
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      saveTimer = null;
      saveNow();
      refreshStorageEstimate();
    }, 250);
  }

  // ===== Storage estimate =====
  async function refreshStorageEstimate() {
    if (!navigator.storage?.estimate) {
      storagePill.textContent = "Storage: (estimate unsupported)";
      return;
    }
    try {
      const est = await navigator.storage.estimate();
      const used = est.usage ?? 0;
      const quota = est.quota ?? 1;
      const pct = Math.min(100, Math.round((used / quota) * 100));
      storagePill.textContent = `Storage: ${fmtBytes(used)} / ${fmtBytes(quota)} (${pct}%)`;
    } catch {
      storagePill.textContent = "Storage: (estimate failed)";
    }
  }
  function fmtBytes(n) {
    const u = ["B","KB","MB","GB"];
    let i = 0, x = n;
    while (x >= 1024 && i < u.length-1) { x /= 1024; i++; }
    return `${x.toFixed(i===0 ? 0 : 1)}${u[i]}`;
  }

  // ===== Helpers =====
  function escapeAttr(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll('"', "&quot;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }
  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;");
  }
  function dataUrlToBlob(dataUrl) {
    const [meta, b64] = dataUrl.split(",");
    const mime = (meta.match(/data:([^;]+)/) || [])[1] || "application/octet-stream";
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return new Blob([bytes], { type: mime });
  }
  function blobToDataURL(blob) {
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(r.result);
      r.onerror = () => reject(r.error);
      r.readAsDataURL(blob);
    });
  }
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 250);
  }
  function safeFileName(name) {
    return (name || "dmm_plan")
      .toLowerCase()
      .replace(/[^a-z0-9\-_]+/g, "_")
      .replace(/_+/g, "_")
      .replace(/^_+|_+$/g, "")
      .slice(0, 60) || "dmm_plan";
  }
  function mimeToExt(mime) {
    const m = (mime || "").toLowerCase();
    if (m.includes("png")) return "png";
    if (m.includes("jpeg") || m.includes("jpg")) return "jpg";
    if (m.includes("webp")) return "webp";
    if (m.includes("gif")) return "gif";
    if (m.includes("bmp")) return "bmp";
    return "bin";
  }
  function normalizePlan(obj) {
    const norm = {
      title: String(obj.title || "Imported plan"),
      selectedSectionId: obj.selectedSectionId || (obj.sections[0]?.id ?? null),
      sections: obj.sections.map(sec => ({
        id: String(sec.id || uid()),
        title: String(sec.title || "Section"),
        open: !!sec.open,
        steps: Array.isArray(sec.steps) ? sec.steps.map(st => ({
          id: String(st.id || uid()),
          title: String(st.title || ""),
          text: String(st.text || ""),
          imageId: typeof st.imageId === "string" ? st.imageId : ""
        })) : []
      }))
    };
    if (!norm.selectedSectionId && norm.sections[0]) norm.selectedSectionId = norm.sections[0].id;
    return norm;
  }

  // ===== Paste support for images =====
  let lastImgTarget = null; // { stepObj, imgEl, hintEl }
  document.addEventListener("paste", async (ev) => {
    if (!lastImgTarget?.stepObj) return;
    const items = ev.clipboardData?.items || [];
    for (const it of items) {
      if (it.type && it.type.startsWith("image/")) {
        const file = it.getAsFile();
        if (!file) return;
        await idbPutImage(lastImgTarget.stepObj.id, file);
        lastImgTarget.stepObj.imageId = lastImgTarget.stepObj.id;

        const url = URL.createObjectURL(file);
        lastImgTarget.imgEl.onload = () => URL.revokeObjectURL(url);
        lastImgTarget.imgEl.src = url;
        lastImgTarget.imgEl.style.display = "block";
        lastImgTarget.hintEl.style.display = "none";

        saveNow();
        refreshStorageEstimate();
        ev.preventDefault();
        return;
      }
    }
  });

  async function setStepImageFromFile(stepObj, imgEl, hintEl, file) {
    if (!file || !file.type?.startsWith("image/")) {
      alert("Please select an image file.");
      return;
    }
    await idbPutImage(stepObj.id, file);
    stepObj.imageId = stepObj.id;

    const url = URL.createObjectURL(file);
    imgEl.onload = () => URL.revokeObjectURL(url);
    imgEl.src = url;
    imgEl.style.display = "block";
    hintEl.style.display = "none";

    saveNow();
    refreshStorageEstimate();
  }

  async function removeStepImage(stepObj, imgEl, hintEl) {
    if (!stepObj.imageId) return;
    await idbDeleteImage(stepObj.imageId);
    stepObj.imageId = "";
    imgEl.removeAttribute("src");
    imgEl.style.display = "none";
    hintEl.style.display = "block";
    saveNow();
    refreshStorageEstimate();
  }

  async function openStepImageLightbox(stepObj) {
    if (!stepObj.imageId) return;
    const blob = await idbGetImage(stepObj.imageId);
    if (!blob) return;
    openLightboxFromBlob(blob, stepObj.title || "Step image");
  }

  // ===== Standalone import (embedded payload) =====
  function simpleHash(s) {
    let h = 2166136261;
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0).toString(16);
  }

  async function importEmbeddedIfPresent() {
    const tag = document.getElementById(EMBED_SCRIPT_ID);
    if (!tag) return;

    const raw = (tag.textContent || "").trim();
    if (!raw) return;

    let payload;
    try { payload = JSON.parse(raw); } catch { return; }
    if (!payload?.plan) return;

    const marker = "dmm_embedded_loaded_" + simpleHash(raw);
    if (localStorage.getItem(marker) === "1") return;

    state = payload.plan;
    if (!state.selectedSectionId && state.sections?.[0]) state.selectedSectionId = state.sections[0].id;

    const imgs = payload.images || {};
    let imported = 0;
    for (const [imageId, dataUrl] of Object.entries(imgs)) {
      try {
        const blob = dataUrlToBlob(dataUrl);
        await idbPutImage(imageId, blob);
        imported++;
      } catch {}
    }

    localStorage.setItem(marker, "1");
    saveNow();
    alert(`Standalone loaded: imported ${imported} image(s).`);
  }

  // ===== Pack (zip) export/import =====
  async function exportPackZip() {
    if (!window.JSZip) {
      alert("JSZip failed to load (offline?).");
      return;
    }
    exportPackBtn.disabled = true;
    exportPackBtn.textContent = "üì¶ Exporting‚Ä¶";
    try {
      const zip = new JSZip();
      zip.file("plan.json", JSON.stringify(state, null, 2));
      const imgFolder = zip.folder("images");

      let count = 0;
      for (const st of allSteps()) {
        if (!st.imageId) continue;
        const blob = await idbGetImage(st.imageId);
        if (!blob) continue;
        imgFolder.file(`${st.imageId}.${mimeToExt(blob.type)}`, blob);
        count++;
      }

      const outBlob = await zip.generateAsync({ type:"blob", compression:"DEFLATE", compressionOptions:{ level:6 } });
      downloadBlob(outBlob, `${safeFileName(state.title)}_pack.zip`);
      alert(`Exported pack with ${count} image(s).`);
    } catch (e) {
      console.error(e);
      alert("Pack export failed (see console).");
    } finally {
      exportPackBtn.disabled = false;
      exportPackBtn.textContent = "üì¶ Export Pack (.zip)";
    }
  }

  async function importPackZip(file) {
    if (!window.JSZip) {
      alert("JSZip failed to load (offline?).");
      return;
    }
    if (!file) return;

    try {
      const buf = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(buf);

      const planFile = zip.file("plan.json");
      if (!planFile) { alert("This zip is missing plan.json"); return; }

      const planStr = await planFile.async("string");
      const obj = JSON.parse(planStr);
      if (!obj || !Array.isArray(obj.sections)) { alert("plan.json invalid."); return; }

      state = normalizePlan(obj);

      // Restore images from images/
      let imgCount = 0;
      const imageEntries = [];
      zip.forEach((path, entry) => {
        if (!entry.dir && path.startsWith("images/")) imageEntries.push(entry);
      });

      for (const entry of imageEntries) {
        const name = entry.name.split("/").pop();
        const id = name.replace(/\.[^.]+$/, "");
        const blob = await entry.async("blob");
        await idbPutImage(id, blob);
        imgCount++;
      }

      // Legacy inline imageData if present
      let migrated = 0;
      for (const sec of obj.sections || []) {
        for (const st of sec.steps || []) {
          if (typeof st.imageData === "string" && st.imageData.startsWith("data:image/")) {
            const stepId = String(st.id || "");
            if (!stepId) continue;
            await idbPutImage(stepId, dataUrlToBlob(st.imageData));
            migrated++;
            const cur = state.sections.flatMap(s => s.steps).find(x => x.id === stepId);
            if (cur) cur.imageId = stepId;
          }
        }
      }

      saveNow();
      await refreshStorageEstimate();
      render();
      alert(`Imported pack.\nImages restored: ${imgCount}\nLegacy inline migrated: ${migrated}`);
    } catch (e) {
      console.error(e);
      alert("Pack import failed (see console).");
    }
  }

  // ===== JSON import/export =====
  function exportJSON() {
    downloadBlob(new Blob([JSON.stringify(state, null, 2)], { type:"application/json" }), "dmm_plan.json");
  }

  async function importJSON(file) {
    const text = await file.text();
    let obj;
    try { obj = JSON.parse(text); }
    catch { alert("Import failed: invalid JSON"); return; }

    if (!obj || !Array.isArray(obj.sections)) { alert("Import failed: missing sections"); return; }

    state = normalizePlan(obj);

    // migrate old inline imageData -> IDB
    let migrated = 0;
    for (const sec of obj.sections || []) {
      for (const st of sec.steps || []) {
        if (typeof st.imageData === "string" && st.imageData.startsWith("data:image/")) {
          const stepId = String(st.id || "");
          if (!stepId) continue;
          await idbPutImage(stepId, dataUrlToBlob(st.imageData));
          migrated++;
          const cur = state.sections.flatMap(s => s.steps).find(x => x.id === stepId);
          if (cur) cur.imageId = stepId;
        }
      }
    }

    saveNow();
    await refreshStorageEstimate();
    render();
    if (migrated > 0) alert(`Imported JSON and migrated ${migrated} image(s).`);
  }

  // ===== Standalone export (self contained HTML) =====
  async function exportStandaloneHTML() {
    exportStandaloneBtn.disabled = true;
    exportStandaloneBtn.textContent = "üß© Exporting‚Ä¶";
    try {
      const images = {};
      let count = 0;
      for (const st of allSteps()) {
        if (!st.imageId) continue;
        const blob = await idbGetImage(st.imageId);
        if (!blob) continue;
        images[st.imageId] = await blobToDataURL(blob);
        count++;
      }
      const payload = { plan: state, images };

      // inject payload into current HTML by replacing the embedded script
      let html = document.documentElement.outerHTML;
      const re = new RegExp(`<script\\s+id="${EMBED_SCRIPT_ID}"\\s+type="application\\/json">[\\s\\S]*?<\\/script>`, "i");

      // IMPORTANT: do NOT include literal </script> in a JS template string in THIS page.
      const embeddedTag =
        `<script id="${EMBED_SCRIPT_ID}" type="application/json">` +
        `${escapeHtml(JSON.stringify(payload))}` +
        `</scr` + `ipt>`;

      html = re.test(html) ? html.replace(re, embeddedTag) : html.replace(/<\/body>/i, embeddedTag + "\n</body>");

      downloadBlob(new Blob([html], { type:"text/html" }), `${safeFileName(state.title)}_standalone.html`);
      alert(`Standalone HTML exported with ${count} image(s).`);
    } catch (e) {
      console.error(e);
      alert("Standalone export failed (see console).");
    } finally {
      exportStandaloneBtn.disabled = false;
      exportStandaloneBtn.textContent = "üß© Export Standalone HTML";
    }
  }

  // ===== AUTO-LOAD ZIP FROM GITHUB PAGES =====
  async function fetchZipAsFile(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("Failed to fetch zip: " + res.status);
    const blob = await res.blob();
    return new File([blob], "auto_pack.zip", { type: "application/zip" });
  }

  async function autoLoadPackIfNeeded() {
    if (!AUTO_PACK_URL) return;

    const key = "dmm_auto_pack_loaded_" + AUTO_PACK_VERSION;
    if (localStorage.getItem(key) === "1") return;

    try {
      const file = await fetchZipAsFile(AUTO_PACK_URL);
      await importPackZip(file);
      localStorage.setItem(key, "1");
      console.log("Auto-pack loaded:", AUTO_PACK_URL);
    } catch (e) {
      console.warn("Auto-pack load failed:", e);
    }
  }

  // ===== Section reordering (drag ‚áÖ) =====
  let draggingSectionId = null;

  function reorderSections(dragId, dropId) {
    if (!dragId || !dropId || dragId === dropId) return;
    const arr = state.sections;
    const from = arr.findIndex(s => s.id === dragId);
    const to = arr.findIndex(s => s.id === dropId);
    if (from < 0 || to < 0) return;
    const [moved] = arr.splice(from, 1);
    arr.splice(to, 0, moved);
    saveNow();
    render();
  }

  // ===== Render =====
  function render() {
    planTitleEl.value = state.title || "";
    const sel = selectedSection();
    selectedLabel.textContent = sel ? sel.title : "(none)";
    countLabel.textContent = `${state.sections.length} section(s)`;

    sectionsRoot.innerHTML = "";

    state.sections.forEach((sec) => {
      const details = document.createElement("details");
      details.className = "section";
      details.open = !!sec.open;

      details.addEventListener("dragover", (ev) => {
        if (!draggingSectionId) return;
        ev.preventDefault();
        details.classList.add("dragOver");
        ev.dataTransfer.dropEffect = "move";
      });
      details.addEventListener("dragleave", () => details.classList.remove("dragOver"));
      details.addEventListener("drop", (ev) => {
        ev.preventDefault();
        details.classList.remove("dragOver");
        const dragId = ev.dataTransfer.getData("text/plain") || draggingSectionId;
        reorderSections(dragId, sec.id);
        draggingSectionId = null;
      });

      const summary = document.createElement("summary");
      summary.className = "sectionSum";
      summary.dataset.sid = sec.id;
      summary.classList.toggle("selected", sec.id === state.selectedSectionId);

      const caret = document.createElement("div");
      caret.className = "caret";
      caret.textContent = details.open ? "‚Äì" : "+";

      const dragHandle = document.createElement("div");
      dragHandle.className = "dragHandle";
      dragHandle.textContent = "‚áÖ";
      dragHandle.title = "Drag to reorder section";
      dragHandle.draggable = true;
      dragHandle.addEventListener("dragstart", (ev) => {
        ev.stopPropagation();
        draggingSectionId = sec.id;
        ev.dataTransfer.effectAllowed = "move";
        ev.dataTransfer.setData("text/plain", sec.id);
      });
      dragHandle.addEventListener("click", (ev) => ev.stopPropagation());

      const titleSpan = document.createElement("div");
      titleSpan.className = "secTitle";
      titleSpan.textContent = sec.title || "Section";
      titleSpan.title = sec.title || "Section";

      summary.innerHTML = `
        <div class="secLeft"></div>
        <div class="secMeta">${(sec.steps||[]).length} step(s)</div>
      `;
      const secLeft = summary.querySelector(".secLeft");
      secLeft.appendChild(dragHandle);
      secLeft.appendChild(caret);
      secLeft.appendChild(titleSpan);

      summary.addEventListener("click", () => setSelectedSection(sec.id));

      details.addEventListener("toggle", () => {
        sec.open = details.open;
        caret.textContent = details.open ? "‚Äì" : "+";
        saveSoon();
      });

      const body = document.createElement("div");
      body.className = "secBody";

      const secTitleRow = document.createElement("div");
      secTitleRow.className = "rowBtns";
      secTitleRow.innerHTML = `
        <div style="flex:1 1 auto; min-width:220px;">
          <div class="muted" style="font-size:12px; margin-bottom:6px;">Section title</div>
          <input type="text" class="secTitleInput" value="${escapeAttr(sec.title || "")}" />
        </div>
        <button class="btn tiny primary" data-act="addStep">‚ûï Add step</button>
        <button class="btn tiny danger" data-act="deleteSec">üóëÔ∏è Delete section</button>
      `;
      body.appendChild(secTitleRow);

      const secTitleInput = secTitleRow.querySelector(".secTitleInput");
      secTitleInput.addEventListener("input", () => {
        sec.title = secTitleInput.value;
        titleSpan.textContent = sec.title || "Section";
        titleSpan.title = sec.title || "Section";
        if (sec.id === state.selectedSectionId) selectedLabel.textContent = sec.title || "Section";
        saveSoon();
      });

      secTitleRow.addEventListener("click", (ev) => {
        const btn = ev.target.closest("button");
        if (!btn) return;
        const act = btn.dataset.act;
        if (act === "addStep") addStepToSection(sec.id);
        if (act === "deleteSec") deleteSection(sec.id);
      });

      (sec.steps || []).forEach((st, stepIndex) => {
        const step = document.createElement("div");
        step.className = "step";

        const stepPicker = document.createElement("input");
        stepPicker.type = "file";
        stepPicker.accept = "image/*";
        stepPicker.className = "hide";

        step.innerHTML = `
          <div class="stepTop">
            <div class="num">${stepIndex + 1}</div>
            <input type="text" class="stepTitle" placeholder="Step title..." value="${escapeAttr(st.title || "")}" />
            <button class="btn tiny danger delStep">Delete</button>
          </div>

          <div class="stepGrid">
            <div>
              <div class="imgBox" tabindex="0" role="button" aria-label="Add image">
                <div class="hint">
                  <b>Image</b><br/>
                  Click to choose ‚Ä¢ Drag/drop ‚Ä¢ Ctrl+V paste<br/>
                  <span class="muted">Click image to view larger</span>
                </div>
                <img alt="Step image"/>
              </div>
              <div class="imgActions">
                <button class="btn tiny removeImg">Remove image</button>
              </div>
            </div>

            <div>
              <textarea class="stepText" placeholder="Write the instructions for this step..."></textarea>
            </div>
          </div>
        `;
        step.appendChild(stepPicker);

        const titleInput = step.querySelector(".stepTitle");
        const textArea = step.querySelector(".stepText");
        const delBtn = step.querySelector(".delStep");

        const imgBox = step.querySelector(".imgBox");
        const imgEl = step.querySelector(".imgBox img");
        const hintEl = step.querySelector(".imgBox .hint");
        const removeImgBtn = step.querySelector(".removeImg");

        textArea.value = st.text || "";

        if (st.imageId) {
          idbGetImage(st.imageId).then((blob) => {
            if (!blob) return;
            const url = URL.createObjectURL(blob);
            imgEl.onload = () => URL.revokeObjectURL(url);
            imgEl.src = url;
            imgEl.style.display = "block";
            hintEl.style.display = "none";
          }).catch(console.warn);
        } else {
          imgEl.style.display = "none";
          hintEl.style.display = "block";
        }

        titleInput.addEventListener("input", () => { st.title = titleInput.value; saveSoon(); });
        textArea.addEventListener("input", () => { st.text = textArea.value; saveSoon(); });

        delBtn.addEventListener("click", async () => {
          if (!confirm("Delete this step?")) return;
          if (st.imageId) await idbDeleteImage(st.imageId);
          sec.steps.splice(stepIndex, 1);
          saveNow();
          refreshStorageEstimate();
          render();
        });

        function setPasteTarget() { lastImgTarget = { stepObj: st, imgEl, hintEl }; }
        imgBox.addEventListener("focus", setPasteTarget);
        imgBox.addEventListener("pointerdown", setPasteTarget);

        imgBox.addEventListener("click", () => {
          imgBox.focus();
          setPasteTarget();
          stepPicker.value = "";
          stepPicker.click();
        });

        stepPicker.addEventListener("change", async () => {
          const file = stepPicker.files && stepPicker.files[0];
          if (!file) return;
          await setStepImageFromFile(st, imgEl, hintEl, file);
        });

        imgBox.addEventListener("dragover", (ev) => { ev.preventDefault(); imgBox.classList.add("dragover"); });
        imgBox.addEventListener("dragleave", () => imgBox.classList.remove("dragover"));
        imgBox.addEventListener("drop", async (ev) => {
          ev.preventDefault();
          imgBox.classList.remove("dragover");
          imgBox.focus();
          setPasteTarget();
          const file = ev.dataTransfer.files && ev.dataTransfer.files[0];
          if (!file) return;
          await setStepImageFromFile(st, imgEl, hintEl, file);
        });

        imgEl.addEventListener("click", async (ev) => {
          ev.stopPropagation();
          await openStepImageLightbox(st);
        });

        removeImgBtn.addEventListener("click", async () => {
          await removeStepImage(st, imgEl, hintEl);
        });

        body.appendChild(step);
      });

      details.appendChild(summary);
      details.appendChild(body);
      sectionsRoot.appendChild(details);
    });
  }

  // ===== Plan actions =====
  function addSection() {
    const title = prompt("Section title?", "New Section");
    if (title === null) return;
    const sec = { id: uid(), title: title.trim() || "New Section", open: true, steps: [] };
    state.sections.push(sec);
    setSelectedSection(sec.id);
    saveNow();
    refreshStorageEstimate();
    render();
  }

  function addStepToSelected() {
    const sec = selectedSection();
    if (!sec) return alert("No section selected. Add a section first.");
    addStepToSection(sec.id);
  }

  function addStepToSection(sectionId) {
    const sec = state.sections.find(s => s.id === sectionId);
    if (!sec) return;
    sec.steps.push({ id: uid(), title: "New step", text: "", imageId: "" });
    sec.open = true;
    setSelectedSection(sec.id);
    saveNow();
    refreshStorageEstimate();
    render();
  }

  async function deleteSection(sectionId) {
    const idx = state.sections.findIndex(s => s.id === sectionId);
    if (idx < 0) return;
    if (!confirm("Delete this entire section (and all its steps)?")) return;

    for (const st of state.sections[idx].steps || []) {
      if (st.imageId) await idbDeleteImage(st.imageId);
    }

    state.sections.splice(idx, 1);

    if (!state.sections.length) {
      state.selectedSectionId = null;
    } else if (state.selectedSectionId === sectionId) {
      state.selectedSectionId = state.sections[Math.max(0, idx - 1)].id;
    }

    saveNow();
    refreshStorageEstimate();
    render();
  }

  async function resetAll() {
    if (!confirm("Reset plan AND delete all stored images?")) return;
    state = DEFAULT_STATE();
    state.selectedSectionId = state.sections[0]?.id || null;
    saveNow();
    await idbClearAllImages();
    await refreshStorageEstimate();
    render();
  }

  // ===== Wire UI =====
  planTitleEl.addEventListener("input", () => { state.title = planTitleEl.value; saveSoon(); });

  addSectionBtn.addEventListener("click", addSection);
  addStepBtn.addEventListener("click", addStepToSelected);

  exportBtn.addEventListener("click", exportJSON);
  importFile.addEventListener("change", async () => {
    const f = importFile.files && importFile.files[0];
    if (f) await importJSON(f);
    importFile.value = "";
  });

  exportPackBtn.addEventListener("click", exportPackZip);
  importPackFile.addEventListener("change", async () => {
    const f = importPackFile.files && importPackFile.files[0];
    if (f) await importPackZip(f);
    importPackFile.value = "";
  });

  exportStandaloneBtn.addEventListener("click", exportStandaloneHTML);
  resetBtn.addEventListener("click", resetAll);

  // ===== Startup =====
  (async () => {
    await importEmbeddedIfPresent();
    await autoLoadPackIfNeeded(); // <-- auto-load hosted zip (GitHub Pages)

    if (!state.selectedSectionId && state.sections[0]) state.selectedSectionId = state.sections[0].id;
    setSaveStatus("Saved", true);
    saveNow();
    render();
    refreshStorageEstimate();
  })();

})(); // end IIFE
</script>

</body>
</html>

